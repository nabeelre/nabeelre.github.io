<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script
            async
            src="https://www.googletagmanager.com/gtag/js?id=G-ZM95CLY1K3"
        ></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag("js", new Date());
            gtag("config", "G-ZM95CLY1K3", {
                "anonymize_ip": true
            });
        </script>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, shrink-to-fit=no"
        />
        <meta name="description" content="Visualization - Nabeel Rehemtulla" />
        <meta name="author" content="Nabeel Rehemtulla" />
        <title>Visualization - Nabeel Rehemtulla</title>
        <!-- Font Awesome icons (free version)-->
        <script
            src="https://use.fontawesome.com/releases/v5.15.1/js/all.js"
            crossorigin="anonymous"
        ></script>
        <!-- Google fonts-->
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <!-- Core theme CSS-->
        <link href="css/styles.css" rel="stylesheet" />
        <!-- Import map to resolve ES module dependencies -->
        <script type="importmap">
        {
            "imports": {
                "apache-arrow": "https://esm.sh/apache-arrow@14.0.1"
            },
            "scopes": {
                "https://esm.sh/": {
                    "apache-arrow": "https://esm.sh/apache-arrow@14.0.1"
                },
                "https://cdn.jsdelivr.net/": {
                    "apache-arrow": "https://esm.sh/apache-arrow@14.0.1"
                }
            }
        }
        </script>
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar">
            <div class="nav-container">
                <a href="index.html" class="nav-logo">Nabeel Rehemtulla</a>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="index.html" class="nav-link">About</a>
                    </li>
                    <li class="nav-item">
                        <a href="research.html" class="nav-link">Research</a>
                    </li>
                    <li class="nav-item">
                        <a href="visualization.html" class="nav-link active">Visualization</a>
                    </li>
                    <li class="nav-item">
                        <a href="assets/docs/NR_CV.pdf" target="_blank" class="nav-link">CV</a>
                    </li>
                </ul>
                <div class="nav-toggle" id="mobile-menu">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </div>
            </div>
        </nav>

        <!-- Visualization Section -->
        <section class="page-section">
            <div class="container visualization-content">
                <h1>Visualization</h1>
                <p class="section-intro">
                    I'm passionate about creating exciting and effective visualizations to disseminate my work. 
                    Here are two examples of such efforts:
                </p>
                <div class="video-card">
                    <div class="video-wrapper">
                        <iframe
                            src="https://www.youtube-nocookie.com/embed/qUwlQflDdEo?si=AdulxxXQlIuAoBlf"
                            title="YouTube video player"
                            width="560"
                            height="315"
                            frameborder="0"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            referrerpolicy="strict-origin-when-cross-origin"
                            allowfullscreen
                            loading="lazy"
                        ></iframe>
                    </div>
                    <p class="video-caption">
                        I created this animation for a visualization competition at a Northwestern Computational Science Symposium where it
                        was awarded first prize. 
                        It captures for a general audience how supernova discovery and classification workflows function
                        and highlights how my BTSbot model enabled the world's first fully automated discovery and classification of a supernova.
                    </p>
                </div>

                <div class="atlas-card">
                    <div class="atlas-card-text">
                        <h2>BTSbot Embedding Atlas</h2>
                        <p>
                            The interactive panel below shows a 2-D view of BTSbot's learned representation of input ZTF data. 
                            You can pan, zoom, filter, and inspect individual sources to help understand what BTSbot is doing. 
                        </p>
                        <p>
                            Tips: Use the top left drop down menu to color points by certain parameters like days_to_peak (an estimate of the source's rise time)
                            or magpsf (the source's brightness in the given alert) to see correlations in the latent space.
                            You can also select regions of the latent space with the rectangle and lasso tools in the bottom bright. For convenience,
                            hide the side and bottom panels with the toggles in the top right corner.
                        </p>
                        <p class="atlas-tip">Note: the interactive panel does not function on some browsers so try another browser if it doesn't load.</p>
                        <div id="embedding-atlas-status" class="atlas-status" role="status" aria-live="polite">
                            Initializing Embedding Atlas…
                        </div>
                    </div>
                    <div id="embedding-atlas-root" class="atlas-view" aria-label="Interactive embedding atlas workspace"></div>
                    <noscript class="atlas-noscript">
                        JavaScript is disabled, so the interactive Embedding Atlas cannot be displayed. Enable JavaScript to explore the embeddings.
                    </noscript>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <p>&copy; <span id="current-year"></span> Nabeel Rehemtulla</p>
            </div>
        </footer>

        <!-- Bootstrap core JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <script type="module">
            const atlasRoot = document.getElementById("embedding-atlas-root");
            const atlasStatus = document.getElementById("embedding-atlas-status");
            const DATA_FILE = "maxvit_gz_emb.csv";
            const CSV_URL = new URL(`./assets/dat/${DATA_FILE}`, window.location.href);
            const DUCKDB_VERSION = "1.30.0";

            async function createDuckDB() {
                const duckdb = await import(
                    `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${DUCKDB_VERSION}/dist/duckdb-browser.mjs`
                );

                // Use absolute paths from root to ensure same-origin and avoid security issues
                const getAssetUrl = (path) => {
                    // Construct absolute URL from root for GitHub Pages compatibility
                    const currentPath = window.location.pathname;
                    const basePath = currentPath.substring(0, currentPath.lastIndexOf('/')) || '';
                    return `${window.location.origin}${basePath}/assets/duckdb-wasm/${path}`;
                };
                
                const bundles = {
                    mvp: {
                        mainModule: getAssetUrl("duckdb-mvp.wasm"),
                        mainWorker: getAssetUrl("duckdb-browser-mvp.worker.js")
                    },
                    eh: {
                        mainModule: getAssetUrl("duckdb-eh.wasm"),
                        mainWorker: getAssetUrl("duckdb-browser-eh.worker.js")
                    }
                };

                const bundle = await duckdb.selectBundle(bundles);
                
                // Check if running from file:// protocol (local file)
                // Workers cannot be loaded from file:// protocol for security reasons
                if (window.location.protocol === 'file:') {
                    throw new Error("Cannot load DuckDB Workers from file:// protocol. Please use a local web server (e.g., 'python -m http.server' or 'npx serve').");
                }
                
                // Create worker - URL should be same-origin to avoid security errors
                // For Safari, ensure the worker URL is absolute
                const workerUrl = bundle.mainWorker;
                let worker;
                try {
                    worker = new Worker(workerUrl);
                } catch (workerError) {
                    // Provide helpful error message for Worker creation failures
                    if (workerError.name === 'SecurityError' || workerError.message.includes('Worker')) {
                        if (window.location.protocol === 'file:') {
                            throw new Error("Workers cannot be loaded from file:// protocol. Please use a local web server.");
                        } else {
                            throw new Error(`Failed to create Worker: ${workerError.message}. This may be due to CORS restrictions or the worker file not being accessible.`);
                        }
                    }
                    throw workerError;
                }
                
                // Add error handler for worker (Safari can be more strict about worker errors)
                worker.onerror = (error) => {
                    console.error("DuckDB Worker error:", error);
                };
                
                const logger = new duckdb.ConsoleLogger();
                const db = new duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                await db.open({
                    filesystem: {
                        forceFullHTTPReads: true
                    }
                });
                const connection = await db.connect();
                return { duckdb: db, connection };
            }

            if (atlasRoot && atlasStatus && !atlasRoot.dataset.initialized) {
                atlasRoot.dataset.initialized = "true";
                (async () => {
                    try {
                        atlasStatus.textContent = "Loading Embedding Atlas modules…";
                        
                        // Check if running from file:// protocol (local file)
                        // Workers cannot be loaded from file:// protocol for security reasons
                        if (window.location.protocol === 'file:') {
                            throw new Error("Cannot load Embedding Atlas from file:// protocol. Please use a local web server (e.g., 'python -m http.server' or 'npx serve').");
                        }
                        
                        // Override Worker constructor to intercept embedding-atlas worker requests
                        // and serve them from local assets to avoid CORS issues
                        const OriginalWorker = window.Worker;
                        // Construct absolute URLs for worker files
                        const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) || '';
                        const workerPathMap = {
                            'search.worker.js': `${window.location.origin}${basePath}/assets/embedding-atlas/search.worker.js`,
                            'clustering.worker.js': `${window.location.origin}${basePath}/assets/embedding-atlas/clustering.worker.js`
                        };
                        
                        window.Worker = class extends OriginalWorker {
                            constructor(scriptURL, options) {
                                try {
                                    const url = typeof scriptURL === 'string' ? new URL(scriptURL, window.location.href) : scriptURL;
                                    const pathname = url.pathname || (typeof scriptURL === 'string' ? scriptURL : '');
                                    
                                    // Check if this is an embedding-atlas worker request from esm.sh or other CDN
                                    if (pathname.includes('search.worker.js') || pathname.includes('clustering.worker.js')) {
                                        const workerName = pathname.includes('search.worker.js') ? 'search.worker.js' : 'clustering.worker.js';
                                        const localPath = workerPathMap[workerName];
                                        if (localPath) {
                                            console.log(`Intercepting worker: ${scriptURL} -> ${localPath}`);
                                            super(localPath, options);
                                            return;
                                        }
                                    }
                                } catch (e) {
                                    console.warn('Error intercepting worker, using original:', e);
                                }
                                // For all other workers, use original behavior
                                super(scriptURL, options);
                            }
                        };
                        
                        // Import modules using esm.sh which automatically resolves all dependencies
                        // The import map above provides fallback resolution for apache-arrow if needed
                        atlasStatus.textContent = "Loading embedding-atlas module…";
                        
                        // Import from esm.sh which handles dependencies correctly
                        const embeddingAtlasModule = await import("https://esm.sh/embedding-atlas@0.12.0/dist/index.js");
                        
                        // Log available exports for debugging
                        console.log("EmbeddingAtlas module exports:", Object.keys(embeddingAtlasModule));
                        console.log("Full module:", embeddingAtlasModule);
                        
                        // EmbeddingAtlas might be a default export or named export
                        let EmbeddingAtlas = embeddingAtlasModule.default || embeddingAtlasModule.EmbeddingAtlas;
                        
                        // If still not found, try the module itself (it might be the class directly)
                        if (!EmbeddingAtlas && typeof embeddingAtlasModule === 'function') {
                            EmbeddingAtlas = embeddingAtlasModule;
                        }
                        
                        // Check if it's a Svelte component (has mount method) or a regular class
                        if (EmbeddingAtlas && typeof EmbeddingAtlas === 'function') {
                            console.log("EmbeddingAtlas is a function/class");
                            console.log("EmbeddingAtlas.length (arity):", EmbeddingAtlas.length);
                            if (EmbeddingAtlas.prototype) {
                                console.log("EmbeddingAtlas has prototype");
                                console.log("EmbeddingAtlas.prototype methods:", Object.getOwnPropertyNames(EmbeddingAtlas.prototype));
                            }
                        }
                        
                        if (!EmbeddingAtlas) {
                            throw new Error("EmbeddingAtlas class not found in module. Available exports: " + Object.keys(embeddingAtlasModule).join(", "));
                        }
                        
                        console.log("EmbeddingAtlas type:", typeof EmbeddingAtlas);
                        console.log("EmbeddingAtlas:", EmbeddingAtlas);
                        
                        atlasStatus.textContent = "Loading mosaic-core module…";
                        const mosaicModule = await import("https://esm.sh/@uwdata/mosaic-core@0.21.1");
                        const Coordinator = mosaicModule.Coordinator;
                        const wasmConnector = mosaicModule.wasmConnector;

                        const coordinator = new Coordinator();
                        const duckdbResources = await createDuckDB();
                        const connector = wasmConnector({
                            duckdb: duckdbResources.duckdb,
                            connection: duckdbResources.connection
                        });
                        coordinator.databaseConnector(connector);
                        
                        // Verify the connector is properly set up
                        // Safari can have timing issues, so we ensure everything is ready
                        if (!connector) {
                            throw new Error("Database connector failed to initialize");
                        }
                        console.log("Database connector initialized:", connector);

                        atlasStatus.textContent = "Downloading embeddings CSV…";
                        const response = await fetch(CSV_URL);
                        if (!response.ok) {
                            throw new Error("Dataset download failed");
                        }
                        const csvBuffer = new Uint8Array(await response.arrayBuffer());

                        atlasStatus.textContent = "Loading data into DuckDB…";
                        await duckdbResources.duckdb.registerFileBuffer(DATA_FILE, csvBuffer);

                        const createTableSQL = `
                            CREATE OR REPLACE TABLE maxvit_embeddings AS
                            SELECT
                                row_number() OVER () AS id,
                                CAST(umap_emb_1 AS DOUBLE) AS x,
                                CAST(umap_emb_2 AS DOUBLE) AS y,
                                source_set,
                                source_set_outlier,
                                fid,
                                field,
                                magpsf,
                                sigmapsf,
                                ra,
                                dec,
                                acai_h,
                                acai_v,
                                acai_o,
                                acai_n,
                                age,
                                days_since_peak,
                                days_to_peak,
                                near_threshold,
                                new_drb,
                                printf(
                                    'FID %d - Field %d - Mag %.2f - RA %.2f - Dec %.2f',
                                    CAST(fid AS INTEGER),
                                    CAST(field AS INTEGER),
                                    CAST(magpsf AS DOUBLE),
                                    CAST(ra AS DOUBLE),
                                    CAST(dec AS DOUBLE)
                                ) AS text
                            FROM read_csv_auto('${DATA_FILE}', header = true, sample_size = -1);
                        `;

                        await coordinator.exec(createTableSQL);
                        
                        // Verify the table was created successfully
                        // This is especially important for Safari which can have timing issues
                        atlasStatus.textContent = "Verifying data table…";
                        const verifyTableSQL = "SELECT COUNT(*) as count FROM maxvit_embeddings LIMIT 1";
                        try {
                            // Use the connection directly to verify the table exists
                            const verifyResult = await duckdbResources.connection.query(verifyTableSQL);
                            if (!verifyResult || verifyResult.toArray().length === 0) {
                                throw new Error("Failed to verify data table creation");
                            }
                            const rowCount = verifyResult.toArray()[0]?.count;
                            console.log("Table verified, row count:", rowCount);
                            if (!rowCount || rowCount === 0) {
                                throw new Error("Data table is empty");
                            }
                        } catch (verifyError) {
                            console.warn("Table verification failed, but continuing:", verifyError);
                            // Don't fail completely, but log the warning
                        }

                        atlasStatus.textContent = "Rendering Embedding Atlas…";
                        
                        // Verify the container element exists and is valid
                        if (!atlasRoot) {
                            throw new Error("Container element 'embedding-atlas-root' not found");
                        }
                        if (!(atlasRoot instanceof HTMLElement)) {
                            throw new Error("Container element is not a valid DOM element");
                        }
                        
                        // Ensure the container is in the DOM
                        if (!atlasRoot.isConnected) {
                            throw new Error("Container element is not connected to the DOM");
                        }
                        
                        // Clear any existing content in the container
                        atlasRoot.innerHTML = '';
                        
                        // Debug: Log the container element to verify it's correct
                        console.log("Initializing EmbeddingAtlas with container:", atlasRoot);
                        console.log("Container type:", atlasRoot.constructor.name);
                        console.log("Container has appendChild:", typeof atlasRoot.appendChild);
                        console.log("Container nodeName:", atlasRoot.nodeName);
                        console.log("Container tagName:", atlasRoot.tagName);
                        
                        // Try creating a wrapper div if the container isn't a div
                        let targetElement = atlasRoot;
                        if (atlasRoot.tagName !== 'DIV') {
                            console.log("Container is not a DIV, creating wrapper");
                            const wrapper = document.createElement('div');
                            wrapper.style.width = '100%';
                            wrapper.style.height = '100%';
                            atlasRoot.appendChild(wrapper);
                            targetElement = wrapper;
                        }
                        
                        // Prepare data configuration object with explicit validation
                        // Safari can be strict about object property access, so we ensure all properties exist
                        const dataConfig = {
                            table: "maxvit_embeddings",
                            id: "id",
                            projection: { 
                                x: "x", 
                                y: "y" 
                            },
                            text: "text",
                            category: "source_set"
                        };
                        
                        // Validate data config before use
                        if (!dataConfig.table || !dataConfig.id || !dataConfig.projection) {
                            throw new Error("Invalid data configuration: missing required properties");
                        }
                        
                        const embeddingViewConfig = {
                            colorScheme: "dark"
                            // Note: embedding-atlas should automatically fall back to WebGL
                            // if WebGPU is not available. The "Could not get WebGPU canvas context"
                            // warning is expected in Firefox and the component should use WebGL instead.
                        };
                        
                        const initialState = {
                            colorBy: "source_set",
                            showBottomMenu: false,
                            displayMode: "density"
                        };
                        
                        // Verify coordinator is ready and can execute queries
                        if (!coordinator) {
                            throw new Error("Coordinator is not initialized");
                        }
                        
                        // Test that the coordinator can execute a simple query
                        // This is especially important for Safari
                        try {
                            await coordinator.exec("SELECT 1 as test");
                            console.log("Coordinator query test successful");
                        } catch (coordTestError) {
                            console.warn("Coordinator query test failed, but continuing:", coordTestError);
                            // Don't fail completely, but log the warning
                        }
                        
                        // Initialize EmbeddingAtlas
                        // Based on the constructor signature (arity: 2), it expects (container, props)
                        console.log("Creating EmbeddingAtlas with target:", targetElement);
                        console.log("EmbeddingAtlas is:", EmbeddingAtlas);
                        console.log("EmbeddingAtlas prototype:", EmbeddingAtlas.prototype);
                        console.log("Data config:", dataConfig);
                        
                        // Detect browser
                        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                        const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                        console.log("Browser is Safari:", isSafari);
                        console.log("Browser is Firefox:", isFirefox);
                        
                        // For Safari, add a small delay to ensure all async operations are complete
                        if (isSafari) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        // For Firefox, add a delay and ensure data is ready
                        if (isFirefox) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                            // Verify the table has data in Firefox
                            try {
                                const testQuery = "SELECT COUNT(*) as count FROM maxvit_embeddings LIMIT 1";
                                const testResult = await duckdbResources.connection.query(testQuery);
                                const count = testResult.toArray()[0]?.count;
                                console.log("Firefox: Table row count:", count);
                                if (!count || count === 0) {
                                    throw new Error("Table is empty in Firefox");
                                }
                            } catch (firefoxTestError) {
                                console.warn("Firefox data verification:", firefoxTestError);
                            }
                        }
                        
                        // Prepare props object - ensure all properties are properly defined
                        // Create a fresh object to avoid any reference issues
                        const props = {
                            coordinator: coordinator,
                            data: {
                                table: dataConfig.table,
                                id: dataConfig.id,
                                projection: {
                                    x: dataConfig.projection.x,
                                    y: dataConfig.projection.y
                                },
                                text: dataConfig.text,
                                category: dataConfig.category
                            },
                            embeddingViewConfig: {
                                colorScheme: embeddingViewConfig.colorScheme
                            },
                            initialState: {
                                colorBy: initialState.colorBy,
                                showBottomMenu: initialState.showBottomMenu,
                                displayMode: initialState.displayMode
                            }
                        };
                        
                        // Validate props object structure
                        if (!props.data || !props.data.table) {
                            throw new Error("Data prop is invalid: table property missing");
                        }
                        if (!props.data.projection || !props.data.projection.x || !props.data.projection.y) {
                            throw new Error("Data prop is invalid: projection properties missing");
                        }
                        if (!props.coordinator) {
                            throw new Error("Coordinator prop is missing");
                        }
                        
                        // Log props structure without coordinator (which has circular references)
                        console.log("Props structure:", {
                            coordinator: "[Coordinator object]",
                            data: props.data,
                            embeddingViewConfig: props.embeddingViewConfig,
                            initialState: props.initialState
                        });
                        
                        // The constructor expects (container, props) based on arity: 2
                        let atlasInstance;
                        try {
                            console.log("Initializing EmbeddingAtlas with direct constructor (container, props)...");
                            console.log("Target element:", targetElement);
                            console.log("Props data table:", props.data.table);
                            
                            atlasInstance = new EmbeddingAtlas(targetElement, props);
                            console.log("EmbeddingAtlas instance created successfully:", atlasInstance);
                            
                            // For Firefox, wait longer and check if the component rendered
                            // The component may need more time to query data and render
                            if (isFirefox) {
                                // Wait longer for Firefox - it may need more time to process queries
                                // The component creates the canvas asynchronously after data loads
                                console.log("Firefox: Waiting for component to render...");
                                await new Promise(resolve => setTimeout(resolve, 3000));
                                
                                // Check again after waiting
                                let checkCount = 0;
                                const maxChecks = 10;
                                while (checkCount < maxChecks) {
                                    const canvas = targetElement.querySelector('canvas');
                                    const svg = targetElement.querySelector('svg');
                                    if (canvas || svg) {
                                        console.log(`Firefox: Found rendering element after ${checkCount + 1} checks`);
                                        break;
                                    }
                                    if (checkCount < maxChecks - 1) {
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                    }
                                    checkCount++;
                                }
                                
                                // Check multiple possible selectors for rendered content
                                const possibleSelectors = [
                                    'canvas',
                                    'svg',
                                    '.embedding-view',
                                    '[class*="embedding"]',
                                    '[class*="atlas"]',
                                    'div[style*="position"]',
                                    'div[style*="width"]'
                                ];
                                
                                let hasContent = false;
                                let foundElement = null;
                                for (const selector of possibleSelectors) {
                                    foundElement = targetElement.querySelector(selector);
                                    if (foundElement) {
                                        hasContent = true;
                                        console.log(`Firefox: Found rendered content with selector: ${selector}`, foundElement);
                                        break;
                                    }
                                }
                                
                                // Also check if the container has any child elements
                                const hasChildren = targetElement.children.length > 0;
                                console.log("Firefox: Component has rendered content:", hasContent);
                                console.log("Firefox: Container has children:", hasChildren, `(${targetElement.children.length} children)`);
                                console.log("Firefox: Container innerHTML length:", targetElement.innerHTML.length);
                                
                                if (!hasContent && !hasChildren) {
                                    console.warn("Firefox: Component may not have rendered. Checking coordinator and data...");
                                    // Try a test query to ensure coordinator is working
                                    try {
                                        const testQuery = "SELECT COUNT(*) as count FROM maxvit_embeddings LIMIT 1";
                                        await coordinator.exec(testQuery);
                                        console.log("Firefox: Coordinator test query successful");
                                        
                                        // Try querying actual data points
                                        const dataQuery = "SELECT x, y FROM maxvit_embeddings LIMIT 10";
                                        const dataResult = await coordinator.exec(dataQuery);
                                        console.log("Firefox: Data query result:", dataResult);
                                    } catch (coordTest) {
                                        console.error("Firefox: Coordinator test query failed:", coordTest);
                                    }
                                } else if (hasChildren) {
                                    console.log("Firefox: Container children:", Array.from(targetElement.children).map(c => ({
                                        tag: c.tagName,
                                        classes: c.className,
                                        id: c.id,
                                        style: c.style.cssText,
                                        innerHTML: c.innerHTML.substring(0, 200) // First 200 chars
                                    })));
                                    
                                    // Check for canvas or svg elements inside the children
                                    const firstChild = targetElement.children[0];
                                    if (firstChild) {
                                        const canvas = firstChild.querySelector('canvas');
                                        const svg = firstChild.querySelector('svg');
                                        console.log("Firefox: Found canvas:", canvas !== null, canvas ? `(${canvas.width}x${canvas.height})` : '');
                                        console.log("Firefox: Found svg:", svg !== null, svg ? `(${svg.clientWidth}x${svg.clientHeight})` : '');
                                        
                                        // Check all descendants for rendering elements
                                        const allCanvases = firstChild.querySelectorAll('canvas');
                                        const allSvgs = firstChild.querySelectorAll('svg');
                                        console.log("Firefox: Total canvases:", allCanvases.length);
                                        console.log("Firefox: Total SVGs:", allSvgs.length);
                                        
                                        if (allCanvases.length > 0) {
                                            allCanvases.forEach((canvas, i) => {
                                                console.log(`Firefox: Canvas ${i}:`, {
                                                    width: canvas.width,
                                                    height: canvas.height,
                                                    clientWidth: canvas.clientWidth,
                                                    clientHeight: canvas.clientHeight,
                                                    style: canvas.style.cssText,
                                                    visible: canvas.offsetWidth > 0 && canvas.offsetHeight > 0
                                                });
                                            });
                                        }
                                        
                                        // Check if the component might need more time to render data
                                        if (allCanvases.length === 0 && allSvgs.length === 0) {
                                            console.warn("Firefox: No canvas or svg found. Component may still be initializing...");
                                            
                                            // Inspect the component instance for any error states
                                            console.log("Firefox: Inspecting component instance:", {
                                                hasComponent: !!atlasInstance.component,
                                                componentKeys: atlasInstance.component ? Object.keys(atlasInstance.component) : [],
                                                containerChildren: atlasInstance.container ? atlasInstance.container.children.length : 0,
                                                currentProps: atlasInstance.currentProps ? Object.keys(atlasInstance.currentProps) : []
                                            });
                                            
                                            // Check if there are any error messages in the container
                                            const errorElements = targetElement.querySelectorAll('[class*="error"], [id*="error"]');
                                            if (errorElements.length > 0) {
                                                console.warn("Firefox: Found potential error elements:", errorElements);
                                            }
                                            
                                            // Log the full DOM structure for debugging
                                            console.log("Firefox: Full container structure:", targetElement.innerHTML.substring(0, 500));
                                        }
                                    }
                                }
                            }
                        } catch (initError) {
                            console.error("Failed to initialize EmbeddingAtlas:", initError);
                            // If there's a Worker CORS issue, it's likely because embedding-atlas
                            // is trying to load workers from a CDN which has CORS restrictions
                            const errorMessage = initError.message || String(initError);
                            if (errorMessage.includes('Worker') || errorMessage.includes('SecurityError') || 
                                (initError.name === 'SecurityError')) {
                                throw new Error("Worker initialization failed due to CORS restrictions. The embedding-atlas library requires Workers to be loaded from the same origin. This is a known limitation when loading from CDNs.");
                            }
                            // If the error mentions 'table' being undefined, it might be because
                            // the component partially initialized before the Worker error
                            if (errorMessage.includes('table') && errorMessage.includes('undefined')) {
                                throw new Error("Component initialization failed: data properties not accessible. This may be due to a Worker CORS issue preventing proper initialization.");
                            }
                            throw initError;
                        }

                        atlasStatus.remove();
                    } catch (error) {
                        console.error(error);
                        // Safely extract error message, handling circular references
                        let errorMessage = "Unknown error";
                        try {
                            if (error && error.message) {
                                errorMessage = error.message;
                            } else if (typeof error === 'string') {
                                errorMessage = error;
                            } else {
                                errorMessage = String(error);
                            }
                        } catch (e) {
                            // If we can't extract the message, use a generic one
                            errorMessage = "Failed to initialize Embedding Atlas";
                        }
                        atlasStatus.textContent = `Embedding Atlas failed to load: ${errorMessage}`;
                        atlasStatus.classList.add("atlas-status-error");
                    }
                })();
            }
        </script>
    </body>
</html>

